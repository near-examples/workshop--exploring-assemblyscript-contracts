# Contract: Greeting

_This contract is part of a workshop on AssemblyScript_

## Contents

- Interface (behavior)
- Models (data)
- Building - For Readabilty - For Cost Optimization
- Testing - Unit Tests - Simululation Tests - Integration Tests

## Interface

```ts
export function showYouKnow(): void;
```

- "View" function (ie. a function that does NOT alter contract state)
- Takes no parameters
- Returns nothing

```ts
export function sayHello(): string;
```

- View function
- Takes no parameters
- Returns a string

```ts
export function sayMyName(): string;
```

- "Call" function (although it does NOT alter state, it DOES read from `context`, [see docs for details](https://docs.nearprotocol.com/docs/roles/developer/contracts/assemblyscript#potential-gotchas))
- Takes no parameters
- Returns a string

```ts
export function saveMyName(): void;
```

- "Call" function (ie. a function that alters contract state)
- Takes no parameters
- Saves the sender account name to contract state
- Returns nothing

```ts
export function saveMyMessage(message: string): bool;
```

- Call function
- Takes a single parameter message of type string
- Saves the sender account name and message to contract state
- Returns nothing

```ts
export function getAllMessages(): Array<string>;
```

- View function
- Takes no parameters
- Reads all recorded messages from contract state (this can become expensive!)
- Returns an array of messages if any are found, otherwise empty array

**Notes**

- All of these methods append to the log for consistency

## Models

_This contract has no models_

## Building

We have several configuration options when compiling AssemblyScript to Wasm.

To take two illustrative extremes, we can compile a readable WAT file (WebAssembly text format) or we can compile a speedy, size-optimized binary (which may leave the WAT format harder to read).

Let's try both.

### Readable Output

To better understand how AssemblyScript is transformed into Wasm, read the contract `.wat` file generated by the following steps.

To generate the `.wat` file alongside the `.wasm` file:

1. **move to the _contract_ folder** (where **this** `README.md` appears: `01.greeting/`)
2. and run `yarn build`

You should see something like

```text
compiling contract [ 01.greeting/main.ts ] to [ out/greeting.{wasm,wat} ]
I/O Read  : 7.899 ms
I/O Write : 3.388 ms
Parse     : 326.413 ms
Compile   : 300.792 ms
Emit      : 135.141 ms
Validate  : 54.424 ms
Optimize  : 0.261 ms
Filesize  : 14.666kb
âœ¨  Done in 2.39s.
```

> **Notes**
>
> - The optimize step took less than half a second
> - The size of this file is about `15kb`

You should now be able to see the`.wasm` and `.wat` files for this contract in a folder called `out`.

Consider scanning the WAT file for any recognizable strings, you may be surprised at what you find.

If interested, these links will help you make sense of the WAT format

- [Learn to Read WAT using AssemblyScript](http://pldev2.cs.umd.edu/as-demo/)
- [WAT file format here](https://developer.mozilla.org/en-US/docs/WebAssembly/Text_format_to_wasm)

### Cost Optimized Output

To generate a speedy, size-optimized version of this contract (which will ultimately cost less to maintain):

1. **move to the _root_ folder** of this repository (where the **main** workshop `README.md` appears)
2. **run** `yarn build greeting`

You should see something like

```text
compiling contract [ 01.greeting/main.ts         ] to [ out/greeting.wasm ]
I/O Read  : 7.957 ms
I/O Write : 0.665 ms
Parse     : 327.135 ms
Compile   : 279.230 ms
Emit      : 42.876 ms
Validate  : 50.480 ms
Optimize  : 2660.980 ms
Filesize  : 14.669kb
âœ¨  Done in 4.54s.
```

> **Notes**
>
> - The optimize step took almost `3 seconds`, about 10X unoptimized time
> - The size of this file is _also_ about `15kb` although `.wasm` file sizes will diverge by 5X with increased contract complexity

## Testing

There are three classes of tests presented here:

- **Unit** tests exercise the methods and models of your contract
- **Simulation** tests provide fine-grained control over economics, contract state and execution context
- **Integration** tests get as close to production as possible with deployment to a local node, BetaNet or TestNet

See `package.json` for various test scripts.

### 1. Unit Tests

Unit tests are written using [`as-pect`](https://github.com/jtenner/as-pect) which provides blazing ðŸ”¥ fast testing with AssemblyScript.

To see unit tests for this contract run

```text
yarn test -f 01.greeting
```

You should see something like this (may be colorized depending on your terminal configuration)

```text
[Describe]: Greeting

 [Success]: âœ” should respond to showYouKnow()
 [Success]: âœ” should respond to sayHello()
 [Success]: âœ” should respond to sayMyName()
 [Success]: âœ” should respond to saveMyName()
 [Success]: âœ” should respond to saveMyMessage()
 [Success]: âœ” should respond to getAllMessages()

    [File]: 01.greeting/__tests__/greeting.spec.ts
  [Groups]: 2 pass, 2 total
  [Result]: âœ” PASS
[Snapshot]: 0 total, 0 added, 0 removed, 0 different
 [Summary]: 6 pass,  0 fail, 6 total
    [Time]: 12.852ms

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  [Result]: âœ” PASS
   [Files]: 1 total
  [Groups]: 2 count, 2 pass
   [Tests]: 6 pass, 0 fail, 6 total
    [Time]: 2350.078ms
âœ¨  Done in 3.01s.
```

You can explore the contents of `01.greeting/__tests__/greeting.spec.ts` for unit test details.

### 2. Simulation Tests

There are two types of simulation tests we can expect to use:

- **`near-vm`** allows us to exercise contract methods inside an exact replica of the on-chain virtual machine
- **Runtime API** exposes interfaces for cross-contract calls and is compatible with popular testing frameworks

Only the first, using `near-vm`, will be addressed in depth here. It's key limitation is that we can only test one contract at a time, invoking methods, observing changes in state and getting a sense of the operating costs of the contract.

#### Simulation Testing with `near-vm`

Run the following commands to simulate calling the method `sayMyName` on this contract

1. First compile (or recompile after changes) the optimized `.wasm` file

   ```text
   yarn build greeting
   ```

2. Then run a simulation test

   ```text
   test:simulate:vm:greeting --method-name sayMyName
   ```

You should see something like the following response

```text
{"outcome":{"balance":"10000000000000000000000000","storage_usage":100,"return_data":
{"Value":"\"Hello, bob!\""},"burnt_gas":41812607821,"used_gas":41812607821,"logs":
["sayMyName() was called"]},"err":null,"receipts":[],"state":{}}
âœ¨  Done in 6.36s.
```

Which can be reformatted for easier scanning

```json
{
  "outcome": {
    "balance": "10000000000000000000000000",
    "storage_usage": 100,
    "return_data": {
      "Value": "\"Hello, bob!\""
    },
    "burnt_gas": 41812607821,
    "used_gas": 41812607821,
    "logs": ["sayMyName() was called"]
  },
  "err": null,
  "receipts": [],
  "state": {}
}
```

> **Notes**
>
> - The value in `return_data` is what we expect if our account name were "bob". But how did that get there? Run `near-vm --help` to see simulation options including control over contract state and execution context as well as network economics.
> - The amounts of `burnt_gas` and `used_gas` are the same, so why two different values? `used_gas` >= `burnt_gas` is always true. If ever a difference, it will be refunded back to the originating account. [See SO for more](https://stackoverflow.com/a/59146364).
> - The entry in `logs` is exactly what we would expect to see.
> - The contract `state` is empty.

Run the following command to simulate calling the method `saveMyName` on this contract

```text
test:simulate:vm:greeting --method-name saveMyName
```

_(You only need to rebuild the contract if you've made changes)_

After reformatting, you should see something like the following response

```json
{
  "outcome": {
    "balance": "10000000000000000000000000",
    "storage_usage": 149,
    "return_data": "None",
    "burnt_gas": 49055516114,
    "used_gas": 49055516114,
    "logs": ["saveMyName() was called"]
  },
  "err": null,
  "receipts": [],
  "state": {
    "c2VuZGVy": "Ym9i"
  }
}
```

> **Notes**
>
> - The absence of value in `return_data` since `saveMyName` has a return type of `void`.
> - The amount of `used_gas` is higher now, by about 7.2 billion units. This difference represents more compute time required to fetch an account name from the `context` object as well as reading and writing to storage
> - The entry in `logs` is exactly what we would expect to see.
> - This time the contract `state` is not empty. It has 1 entry, a `key : value` pair, that is encoded as Base64 and, when decoded looks like this: `{"sender":"bob"}`.

---

**A brief aside on decoding base64**

The state key and value above was decoded using the code snippet below on macOS but we could have just used a [website like this one](https://www.base64decode.org/). If you prefer to decode using JavaScript you can use the code snippet below to decode your own state.

```js
const utf8 = Buffer.from(data, "base64").toString("utf8");
console.log(utf8);
```

#### Simulation Testing with Runtime API

At a very high level, testing with the Runtime API looks like this

```js
const Runtime = require("near-sdk-as/runtime").Runtime;
const path = require("path");

const contractWasm = path.join(__dirname, "../out/greeting.wasm");

describe("Greeting ", function () {
  const alice = "alice";
  let runtime;
  let contract;

  function invokeContractMethod(type, name, params = {}) {
    // this ends up being one of the following
    //    contract.view("sayHello");
    //    contract.call("sayMyName");
    const response = contract[type](name, params);

    if (response.return_data) {
      return response.return_data;
    } else if (response.return_value) {
      return response.return_value.replace(/\\([\s\S])|(")/g, "");
    } else {
      return response;
    }
  }

  beforeAll(function () {
    runtime = new Runtime();
    contract = runtime.newAccount(alice, contractWasm);
  });

  describe("View methods", function () {
    it("responds to sayHello()", function () {
      const message = invokeContractMethod("view", "sayHello");
      expect(message).toEqual("Hello!");
    });
  });

  describe("Call methods", function () {
    it("responds to sayMyName()", function () {
      const message = invokeContractMethod("call", "sayMyName");
      expect(message).toEqual(`Hello, ${alice}!`);
    });
  });
});
```

To try this out:

1. **move to the _contract_ folder** (where **this** `README.md` appears: `01.greeting/`)
2. create a new file at this path `01.greeting/__tests__/runtime.spec.js` (note it is a `.js` file while the unit tests are in a `.ts` file)
3. copy and paste the Runtime API code snippet (see above) into the `runtime.spec.js` file
4. run `npx jest -f runtime` _(Jest is not included as a repo dependency here so we use `npx` instead)_

You should see something like

```text
npx: installed 506 in 11.469s
 PASS  __tests__/runtime.spec.js
  Greeting
    View methods
      âœ“ responds to sayHello() (116ms)
    Call methods
      âœ“ responds to sayMyName() (110ms)

Test Suites: 1 passed, 1 total
Tests:       2 passed, 2 total
Snapshots:   0 total
Time:        1.227s
```

---

**A brief aside on contracts and accounts**

You may have noticed that the words `contract` and `account` are sometimes interchangeable in this context. This is because NEAR accounts can only hold zero or one contracts while contracts can be deployed to any number of accounts.

In the previous sections, since we were still testing and simulating and had not deployed anything to the network, the words `contract` and `account` were basically the same.

In the next section about integration tests we will deploy the contract to a specific account (ie. the "contract account") on the network (ie. TestNet) and start calling the contract methods from a **different** account (ie. our "user account"). This is when the distinction between the words `contract` and `account` will become useful and important.

You can read more about [accounts on NEAR Protocol here](https://docs.nearprotocol.com/docs/concepts/account).

---

### Integration Tests

There are two types of integration tests we can expect to use:

- **NEAR Shell** serves as a console swiss army knife with the ability to manage accounts, contracts and more
- **`near-api-js`** (our JavaScript API) wraps the NEAR JSON RPC API and exposes NEAR Wallet authentication

Only the first, using NEAR Shell, will be addressed here. It's key limitation is that we cannot orchestrate cross-contract calls. We will use NEAR Shell to create new accounts for contracts before we deploy, verify, and invoke methods on those contracts and finally deleting the contract accounts to clean up after ourselves. We will rely on other tools like [NEAR Explorer](https://explorer.nearprotocol.com/) for transaction visibilty, history and more.

**HEADS UP** -- if this is your first time using NEAR Shell to deploy a contract to TestNet, this may feel like a long and confusing process but once you've done it 3 times, it should only take about a minute from end to end and can be automated in a shell script.

But first the tldr; for anyone who wants to start running before they walk.

---

**tldr;**

We use the symbol `<???>` to represent text that is **unique to your account name**, whatever that is (or will be when you make it up). After this brief list of steps, each of these commands is described in greater detail including expected output and possible errors.

Note that all of this happening **on the command line.**

**(0) Confirm NEAR Shell is installed**

```text
near --version
```

_Expected output_

```text
0.21.0    (or any higher version number)
```

**(1) Authorize NEAR Shell to use your account**

- You must create an account in this step if you don't already have one

```text
near login
```

**(2) Create an account for the contract**

- By design there is a limit of max 1 contract per account
- Account names follow a pattern similar to DNS
- We assume you already created `<???>.testnet` in the previous step

```text
near create_account greeting.<???>.testnet --masterAccount <???>.testnet --helperUrl https://helper.nearprotocol.com
```

_Expected output_

```text
Account greeting.<???>.testnet for network "default" was created.
```

**(3) Build the contract**

- The Wasm file will appear as `out/greeting.wasm`
- To silence metrics reporting during compilation, comment out all (2) instances of `"--measure"` in the file `asconfig.js`

```text
yarn build greeting
```

_Expected output_

```text
compiling contract [ 01.greeting/main.ts         ] to [ out/greeting.wasm ]
```

**(4) Deploy the contract to the contract account**

- We assume you already created `greeting.<???>.testnet` in a previous step

```text
near deploy --wasm-file out/greeting.wasm --accountId greeting.<???>.testnet
```

_Expected output_

```text
Starting deployment. Account id: greeting.<???>.testnet, node: https://rpc.testnet.nearprotocol.com, helper: https://helper.testnet.nearprotocol.com, file: out/greeting.wasm
```

**(5) Verify deployment of the correct contract to the intended**

- The account name `greeting.<???>.testnet` should match the intended contract account
- The value of `code_hash` should match _exactly_ (starting with `63tSDQ...`) **unless the contract code has changed**, in which case it will almost certainly be different.
- Other values in this response are unlikely to match

```text
near state greeting.<???>.testnet
```

_Expected output_

```text
Account greeting.<???>.testnet
```

```json
{
  "amount": "99999999949722583262485000",
  "locked": "0",
  "code_hash": "63tSDQc9K5Nt9C8b1HDkv3VBnMFev9hXB589dZ9adsKA",
  "storage_usage": 14912,
  "storage_paid_at": 0,
  "block_height": 2048367,
  "block_hash": "AbYg6aAbv4e1h2rwKG2vMsWphXm27Ehhde6xUKYzYjsT",
  "formattedAmount": "99.999999949722583262485"
}
```

**(6) For each method of the contract, test it and observe the response**

**Test `showYouKnow()`**

```text
near view greeting.<???>.testnet showYouKnow --accountId <???>.testnet
```

_Expected outcome_

```text
View call: greeting.<???>.testnet.showYouKnow()
[greeting.<???>.testnet]: showYouKnow() was called
false
```

**Test `sayHello()`**

```text
near view greeting.<???>.testnet sayHello --accountId <???>.testnet
```

_Expected outcome_

```text
View call: greeting.<???>.testnet.sayHello()
[greeting.<???>.testnet]: sayHello() was called
'Hello!'
```

**Test `sayMyName()`**

```text
near call greeting.<???>.testnet sayMyName --accountId <???>.testnet
```

_Expected outcome_

```text
Scheduling a call: greeting.<???>.testnet.sayMyName()
[greeting.<???>.testnet]: sayMyName() was called
'Hello, <???>.testnet!'
```

**Test `saveMyName()`**

```text
near view greeting.<???>.testnet saveMyName --accountId <???>.testnet
```

_Expected outcome_

```text
Scheduling a call: greeting.<???>.testnet.saveMyName()
[greeting.<???>.testnet]: saveMyName() was called
''
```

**Test `saveMyMessage()`**

```text
near call greeting.<???>.testnet saveMyMessage '{"message": "bob? you in there?"}' --accountId <???>.testnet
```

_Expected outcome_

```text
Scheduling a call: greeting.<???>.testnet.saveMyMessage({"message": "bob? you in there?"})
[greeting.<???>.testnet]: saveMyMessage() was called
true
```

**Test `getAllMessages()`**

```text
near call greeting.<???>.testnet getAllMessages --accountId <???>.testnet
```

_Expected outcome_

```text
Scheduling a call: greeting.<???>.testnet.getAllMessages()
[greeting.<???>.testnet]: getAllMessages() was called
[ '<???>.testnet says bob? you in there?' ]
```

**(7) Cleanup by deleting the contract account**

```text
near delete greeting.<???>.testnet <???>.testnet
```

_Expected outcome_

```text
Deleting account. Account id: greeting.<???>.testnet, node: https://rpc.testnet.nearprotocol.com, helper: https://helper.testnet.nearprotocol.com, beneficiary: <???>.testnet
Account greeting.<???>.testnet for network "default" was deleted.

```

**END tldr;**
